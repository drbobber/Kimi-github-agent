import { spawn } from 'child_process';
import { buildImplementationPrompt, buildFixPrompt, buildReviewResponsePrompt } from './prompt-builder.js';
import { createPullRequest, addComment, addLabels, removeLabel } from './github-api.js';
import { notifyHumanRequired } from './notifier.js';

/**
 * Process a task using Kimi CLI
 */
export async function processTask(task, workspaceManager, contextManager) {
  const { action, repository, issue, pullRequest, workflowRun } = task;

  try {
    // Step 1: Clone/sync repository
    console.log(`ðŸ“¥ Syncing repository: ${repository}`);
    await workspaceManager.cloneIfNeeded(repository);
    await workspaceManager.syncRepo(repository);

    // Step 2: Install dependencies
    await workspaceManager.installDependencies(repository);

    // Step 3: Handle different task types
    switch (action) {
      case 'implement_issue':
        return await handleImplementIssue(task, workspaceManager, contextManager);
      
      case 'fix_pr_failures':
        return await handleFixPRFailures(task, workspaceManager, contextManager);
      
      case 'respond_to_review':
        return await handleReviewResponse(task, workspaceManager, contextManager);
      
      default:
        throw new Error(`Unknown action: ${action}`);
    }
  } catch (error) {
    console.error(`âŒ Task processing failed:`, error);
    throw error;
  }
}

/**
 * Handle issue implementation
 */
async function handleImplementIssue(task, workspaceManager, contextManager) {
  const { repository, issue } = task;
  const issueNumber = issue.number;

  console.log(`ðŸŽ¯ Implementing issue #${issueNumber}`);

  // Create issue branch
  const branchName = workspaceManager.createIssueBranch(repository, issueNumber);
  const repoPath = workspaceManager.getRepoPath(repository);

  // Build prompt
  const prompt = buildImplementationPrompt(task, branchName);
  
  // Execute Kimi CLI
  const sessionId = `${repository.replace('/', '-')}-issue-${issueNumber}`;
  await executeKimi(repoPath, prompt, sessionId, contextManager);

  // Commit and push
  const commitMessage = `feat: implement issue #${issueNumber}\n\n${issue.title}`;
  const hasChanges = await workspaceManager.commitAndPush(repository, commitMessage, branchName);

  if (!hasChanges) {
    throw new Error('No changes were made by Kimi');
  }

  // Create pull request
  const prTitle = `[Kimi] ${issue.title}`;
  const prBody = `Closes #${issueNumber}\n\nThis PR was automatically generated by Kimi GitHub Agent.\n\n## Changes\n\nImplemented solution for issue #${issueNumber}.`;
  
  const pr = await createPullRequest(
    repository,
    branchName,
    prTitle,
    prBody,
    process.env.DEFAULT_BASE_BRANCH || 'main'
  );

  console.log(`âœ… Pull request created: #${pr.number}`);

  // Update labels
  await addLabels(repository, issueNumber, ['kimi-implemented']);
  await removeLabel(repository, issueNumber, 'kimi-working').catch(() => {});

  return {
    success: true,
    branch: branchName,
    pr: pr.number,
    url: pr.html_url
  };
}

/**
 * Handle PR failure fixes
 */
async function handleFixPRFailures(task, workspaceManager, contextManager) {
  const { repository, pullRequest, workflowRun } = task;
  const prNumber = pullRequest.number;

  console.log(`ðŸ”§ Fixing PR #${prNumber} failures`);

  // Get PR branch and check it out
  const branch = pullRequest.head.ref;
  const repoPath = workspaceManager.getRepoPath(repository);
  
  await workspaceManager.syncRepo(repository, branch);

  // Build fix prompt with error logs
  const prompt = buildFixPrompt(task);
  
  // Execute Kimi CLI
  const sessionId = `${repository.replace('/', '-')}-pr-${prNumber}`;
  await executeKimi(repoPath, prompt, sessionId, contextManager);

  // Commit and push fixes
  const attempt = task.retries + 1;
  const commitMessage = `fix: address CI failures in PR #${prNumber} (attempt ${attempt})`;
  const hasChanges = await workspaceManager.commitAndPush(repository, commitMessage, branch);

  if (!hasChanges) {
    // No changes made - might need human intervention
    await notifyHumanRequired(task, 'Kimi could not produce fixes for the CI failures');
    await addComment(
      repository,
      prNumber,
      'âš ï¸ Automated fix attempt did not produce changes. Human review may be needed.'
    );
  }

  return {
    success: hasChanges,
    branch,
    attempt
  };
}

/**
 * Handle review comments response
 */
async function handleReviewResponse(task, workspaceManager, contextManager) {
  const { repository, pullRequest, review } = task;
  const prNumber = pullRequest.number;

  console.log(`ðŸ’¬ Responding to review on PR #${prNumber}`);

  // Get PR branch
  const branch = pullRequest.head.ref;
  await workspaceManager.syncRepo(repository, branch);

  // Build response prompt
  const prompt = buildReviewResponsePrompt(task);
  const repoPath = workspaceManager.getRepoPath(repository);
  
  // Execute Kimi CLI
  const sessionId = `${repository.replace('/', '-')}-pr-${prNumber}-review`;
  await executeKimi(repoPath, prompt, sessionId, contextManager);

  // Commit changes
  const commitMessage = `fix: address review comments in PR #${prNumber}`;
  await workspaceManager.commitAndPush(repository, commitMessage, branch);

  return {
    success: true,
    branch
  };
}

/**
 * Execute Kimi CLI with the given prompt
 */
async function executeKimi(workingDir, prompt, sessionId, contextManager) {
  return new Promise((resolve, reject) => {
    const kimiPath = process.env.KIMI_PATH || 'kimi';
    const timeout = parseInt(process.env.TASK_TIMEOUT_MS || '900000'); // 15 minutes default

    console.log(`ðŸ¤– Executing Kimi CLI in ${workingDir}...`);

    // Track context
    contextManager.addMessage(sessionId, 'user', prompt);

    const kimi = spawn(kimiPath, [prompt], {
      cwd: workingDir,
      stdio: ['pipe', 'pipe', 'pipe'],
      shell: true
    });

    let output = '';
    let errorOutput = '';

    kimi.stdout.on('data', (data) => {
      const text = data.toString();
      output += text;
      process.stdout.write(text); // Stream output to console
    });

    kimi.stderr.on('data', (data) => {
      const text = data.toString();
      errorOutput += text;
      process.stderr.write(text);
    });

    // Set timeout
    const timeoutId = setTimeout(() => {
      kimi.kill('SIGTERM');
      reject(new Error(`Kimi execution timed out after ${timeout}ms`));
    }, timeout);

    kimi.on('close', (code) => {
      clearTimeout(timeoutId);
      
      // Track response in context
      contextManager.addMessage(sessionId, 'assistant', output || errorOutput);

      if (code === 0) {
        console.log(`âœ… Kimi execution completed successfully`);
        resolve({ output, exitCode: code });
      } else {
        reject(new Error(`Kimi exited with code ${code}: ${errorOutput}`));
      }
    });

    kimi.on('error', (error) => {
      clearTimeout(timeoutId);
      reject(new Error(`Failed to execute Kimi: ${error.message}`));
    });
  });
}
